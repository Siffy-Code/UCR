\documentclass[11pt]{article}

\usepackage{fullpage,graphicx,latexsym,picinpar,amsbsy,amsmath,amsfonts}

\input{macros.tex}

\begin{document}
    \textbf{20240416}
    \textbf{Chapter 3 details}\\
    Prerequisites to begin working on a project:\\
    (0) - Starts with the Problem Definition (what details are desired)\\
    (a) List of requirements (gathered via user stories)\\
    (b) Architecture of the Problem\\
    \textit{CONCEPT}: The earlier a defect occurs in the process and later 
    it is detected, the more costly the problem\\
    \\
    \textbf{UML Usage (4/16 and 4/18)}\\
    $\rightarrow$ Only class diagrams will be used for project\\
    \indent $\bullet$ Organize class hierarchy\\
    \indent $\bullet$ - sign is private. + sign is public.  \\
    \indent $\bullet$ Generalization relationship - inheritance - triangle to base class  \\
    \indent $\bullet$ Association relationship - aggregation - stored as a variable in another class - solid line  \\
    \indent\indent$\bullet$ Full or empty diamond included for composition versus aggregation \\
    \indent\indent$\bullet$ Composition is most typical; aggregation is different (more like working together)\\
    \indent $\bullet$ Object type is not relevant in UML (pointer or not) - only shows up within class card  \\
    \indent $\bullet$ Book+Pages are composition; not a book without pages/cover \\
    \indent $\bullet$ Dependency (third relationship) \\
    \indent\indent $\bullet$ Example: function in class A uses class B in a function \\
    \indent $\bullet$ Place Abstract Classes with italic class name in UML \\
    \indent $\bullet$ Entity versus Boundary versus Control \\
    \indent\indent $\bullet$ MVC design - Model View Controller \\
    \indent\indent $\bullet$ Model: Entity\\
    \indent\indent $\bullet$ View: Boundary (user interface)\\
    \indent\indent $\bullet$ Controller: Control that manipulates interaction between model and view\\
    \indent\indent $\bullet$ Separation of UI and model code allows for simple classes \\
    \indent $\bullet$ Pure Virtual Functions have no additional distinction, can be bold/italics\\
    \indent $\bullet$ 
    \\ \\
    \textbf{20240417 Discussion : GDB and Valgrind}\\
    g++ filename.ext -g -o newfile.exe\\
    (gdb) break line-number\\
    (gdb) print variablename\\
    (gdb) step - goes into the function code\\
    (gdb) next - runs function but does not enter function code\\
    (gdp) continue - runs to end\\
    (gdb) info breakpoints\\
    (gdb) del break 1\\
    (gdb) quit\\
    exiting the debugger also removes breakpoints\\
\\
Valgrind:\\
Memory debugging via memcheck
g++ -g -O0 *.cpp -o newfile.exe\\
valgrind --leak-check=full filename.exe\\
--track-origins=yes gives locations of memory leaks\\
\\
\textit{additional valgrind details:}\\
valgrind ./filename.exe (runs valgrind and gives list of issues)\\
Commands show up in the output for further commands\\
\\
\textbf{Unit Testing: 20240423}\\
\indent $\bullet$ Manufacturer to Quality relationships \\
\indent $\bullet$ Unit Tests should be on github pull requests \\
\indent $\bullet$ Protects your code from others' mistakes \\
\indent $\bullet$ Write Failing Test - Make Code Work - Eliminate Redundancy \\
\indent $\bullet$ Unit Testing Versus Integration Tesing \\
\indent\indent $\bullet$ Unit Testing: SUT (System Under Testing)\\
\indent\indent\indent  $\bullet$ Arrange: Open part of app to test\\ 
\indent\indent\indent  $\bullet$ Act: apply stimulus to part of app \\
\indent\indent\indent  $\bullet$ Assert: observe resulting behavior and verify results  \\
\indent\indent $\bullet$ Google Test: gtest primer - assertions \\
\indent\indent $\bullet$ Assert Versus Expect true/equal/etc. \\
\indent\indent\indent $\bullet$ Assert fails mid-function if incorrect state \\
\indent\indent\indent $\bullet$ Expect continues to end of function even if state fails \\
\indent\indent $\bullet$ Test cases should not throw, but do more expect/assert cases against values like nullptr \\
\indent\indent $\bullet$ Assert is best used when a test after may seg-fault \\
\indent\indent $\bullet$ EXPECT NEAR will take error margin as third argument \\
\indent\indent $\bullet$ Can use stringstream to store integer values to compare to specific decimal places \\
\indent\indent\indent $\bullet$ Can use output streams as an argument for the location of an output \\
\\
\textbf{Stubs and Drivers}\\
\indent $\bullet$ Top-Down = Stub\\
\indent $\bullet$ Bottom-Up = Driver \\
\indent $\bullet$ Driver: Module that calls your program\\
\indent $\bullet$ Stub: Being called by the program\\
\\
\textbf{Function and Non-Function Testing}\\
\indent $\bullet$ Function: The actual output value of the test\\
\indent $\bullet$ Non-Function: Formatting issues, etc.\\
\indent $\bullet$ Stress testing, like having tons of users log in at once, is non-function\\
\\
\textbf{Project Testing}\\
\indent $\bullet$ Code Coverage in Testing:\\
\indent $\bullet$ Coverage = Lines Executed by Tests / Total Lines\\
\indent $\bullet$ 80 percent is required coverage \\
\\
\textbf{Continuous Integration}\\
\indent main.yml\\
\indent Change actions/checkout@v4\\
\indent "Makefile" for github, testing, etc. as a report\\
\indent Can run several "steps" (or programs, tests, etc.)\\
\\
\textbf{Interfaces}\\
\indent $\bullet$ Interface of a class with 3 functions is those three functions \\
\indent $\bullet$ The "Set of Actions" that can be done with this class \\
\indent $\bullet$ Use of different variable naming convetions for private vs prot. \\
\indent $\bullet$ Go Interface (slide) \\
\indent $\bullet$ Dynamic Binding and parent-class pointers (elf family from 10B) \\
\indent $\bullet$ Push cat and dog objects into an animals vector \\
\indent $\bullet$ In Essence, writing an Interface in C++ is writing a class \\
\indent $\bullet$ Creates a duality between interface and implementation without affecting each other \\
\\
\textbf{Iterators}\\
\indent Universal Container Navigator, can be reused in the same piece of code for different data
structures.\\
\indent The primary feature of iterators is that it can be used universally for functions regardless of data type\\
\indent\indent This makes them good candidates for template classes that have search/output/etc. but potentially
handle different conainers.\\
\indent Deleting an item at an iterator location sends the iterator forward to the next object, not back.\\
\indent Insert function should be the same regardless of the data structure.\\
\indent Inserter will allow inserting an array into another array at a particular spot.\\
\indent Iterators may need to be refreshed if the size of the container is being incremented; "advance" may
not work over "next".\\
\\
\textbf{SOLID} \\
\indent $\bullet$ Single-Responsibility Principle (SRP) \\
\indent\indent $\bullet$ Splitting up large functions into their individual parts \\
\indent\indent $\bullet$ Reduction down to a single task per function \\
\indent\indent $\bullet$ Makes the code more testable \\
\indent\indent $\bullet$ Coffee shop example: have an address class that holds the various address details \\
\indent $\bullet$ Open-Closed Principle (OCP) \\
\indent\indent $\bullet$ If editing a class for new functionality, do not change existing functionality \\
\indent\indent $\bullet$ Being able to extend the class without having to modify it (think templates) \\
\indent\indent $\bullet$ Coffee shop violation was multiple if statements instead of inherent invoice object \\
\indent $\bullet$ Liskov Substitution Principle (LSP) \\
\indent\indent $\bullet$ Should be able to substitute a derived class into a base class tests and not violate \\
\indent\indent $\bullet$ Derived classes should all use the same function in the same way \\
\indent\indent $\bullet$ Create interface class to deal with issues \\
\indent $\bullet$ Interface Segregation Principle (ISP) \\
\indent\indent $\bullet$ Break down complicated or invalid instruction lists into separate tasks \\
\indent\indent $\bullet$ Make a second abstract class derived from another with the "extra" function needed \\
\indent $\bullet$ Dependency Inversion Principle (DIP) \\
\indent\indent $\bullet$ Create sub classes of a particular method with their own methods/implementation \\
\indent\indent $\bullet$ High level modules should not depend on details of lower level modules \\
\indent\indent $\bullet$  \\
\\
\textbf{20240516 Notes (Exam 2)}\\
\indent $\bullet$  \\
\indent $\bullet$  \\
\indent $\bullet$  \\
\indent $\bullet$  \\
\indent $\bullet$  \\
\indent $\bullet$  \\
\indent $\bullet$  \\
\indent $\bullet$  \\
\\
\\
\textbf{Exam1}\\
\indent Testing is last topic in order \\
\indent Labs 1-4 \\
\indent Mostly Multiple Choice, Some Open-Ended questions\\
\indent Not memorization-heavy \\
\indent Cheat-Sheet: One page, double sided - can be printed super tiny \\
\indent Know meanings of function calls but not necessarily memorize the calls \\
\indent Discussion Review Session 5/8\\
\indent VIM - create file, save file, compile with debug flags, valgrind errors\\
\indent GDB - run, break, print, next vs step\\
\indent GITHUB FLOW - commands, flow, fetch vs pull, add vs commit (fetch is latest changes without merge)\\
\indent\indent CLONE, PUSH, STATUS, REVERT, BRANCH, checkout\\
\indent Development Methods:\\
\indent\indent Cowboy Coding, Waterfall Method, Agile, Kanban, Scrum\\
\indent Scrum Pros and Cons \\
\indent User Stories process, format, epic versus story, and the three C's \\
\indent\indent Card, Conversation, Confirmation (definition that feature is done)\\
\indent LAB 3 concepts - be able to identify/fix errors from valgrind  \\
\indent UML \\
\indent UNIT TESTING expect versus assert \\
\indent Testing Methodologies\\
\indent\indent Test Driven Design, Integration, BottomUp/TopDown, Function, NonFunction\\
\indent \\ 

\end{document}